Процессы в системе UNIX

Основные концепты поддерживаемые UNIX
    процессы
    память
    файловая система 
    ввод/вывод

Едиственными активными сущностями являются процессы
Каждый процесс запускает одну программу и изначально один поток управления
У каждого процесса есть один счетчик команд, указывающий на следующую выполняемую команду процессора
Большинство UNIX позволяют процессу после того как он запущен создавать дополнительные потоки
UNIX представляет собой многозадачную систему с работающими одновременно независимыми процессами, называемыми демонами


Создание процесса в системе UNIX
    системный вызов fork() создает точную копию исходного процесса, называемого родительским процессом
    новый процесс называется дочерним
    у родительского и дочернего собственные образы памяти
    если родительский процесс изменяет переменные о них не видят и дочерние и наоборот
    открытые файлы совместно используются родитесльскими и дочерними файлами
    системные вызов fork() возвращает дочернему процессу PID 0, а родительскому отлично от нуля
    процессы распознаются по PID идентификаторам
    процессы в UNIX могут общаться друг с другом с помощью разновидности обмена сообщениями
    создается канал между двумя процессами, называемые трубами
    процессы могут общаться при помощи программных прерываний
    один процесс может передать другому так называемый сигнал

Системные вызовы управления процессами UNIX 
    системные вызовы предназначены для управления процессами
    создавая точную копию оригинального процесса включая описатели файла создавая регистры и все остальное
    после выполнения системного вызова родительский процесс и дочерний идут своим путем
    сразу после выполнения системного вызова значения переменных одинаково
    далее изменения значений переменных родительского и дочернего процесса не влияют друг на друга
    системный процесс fork() возвращает значение равное нулю для дочернего процесса и равное идентификатору PID для родительского
    если процесс завершил свою работу, а родительский процесс не ожидает этого события, то дочерний процесс переводится в состояние zombie, то есть приостанавливается
    чтобы заявить о своем желании перехватить используется системный вызов sigAction
sigAction
    первый параметр - сигнал, который требуется перехватить
    второй параметр - указатель на структуру, в которой находится указатель на процедуру обработки сигнала
    третий параметр - на структуру, в котоорй система возвращает об обрабатываемом сигнале, если его позднее можно будет восстановить

Для прерывания процесса через определенный интервал времени используется сигнал alarm
    у каждого процесса может быть только один будильник
    установка значения 0 отменяет другие установки

Системные вызовы управления потоками
    в соответствие с кодикс потоки реализуются либо в потоке ядра, либо в пространстве пользователя
    преимущества
        в пользовательского пространстве легко реализуются без необходимости изменения ядра
        переключение потоков быстро и эфективно
    недостаток
        если один из потоков блокируются - все потоки блокируются
        ядро полагает только существование одного потока и до снятия блокировки не передает управление процессу

Поток создается вызовом 
    завершается exit

синхронизация потоков осуществляется при помощи мьютексов
чтобы гарантировать, что только один поток в каждый момент времени имеет доступ к общему ресурсу потоки блокируют мьютекс перед обращением к ресурсу и разблокируют когда ресурс более не нужен

мьютексы предназначены для кратковременной блокировки, например совместно используемой переменной 
для долговременной реализации используются переменные состояния
используются следующим образом
    один поток ждет когда переменная примет определенные значения
    а другой потом сигнализирует изменения этой переменной

Реализация процессов UNIX
у каждого процесса есть пользовательская часть, в которой работает программа пользователя
когда один из его потоков обращается к системному вызову происходит эмулированное прерывание с переключением в режим ядра
после этого поток в контексте режиме ядра с отличной другой картой памяти и полным доступом в режиме машины

Ядро поддерживает две ключевые структуры данных
    таблицу процессов(дескрипторы)
    структуру пользователя(контекст процессов)

Таблица является резидентной
    содержит информацию для всех процессов, в том числе и даже отсутствующих в памяти

Структура пользователя выгружается на диск освобождая место в памяти, когда процесс отсутствует в памяти

Категории в таблице дескрипторов
    